-- This file is part of cq2rdf.

-- cq2rdf is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- cq2rdf is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.

-- You should have received a copy of the GNU General Public License
-- along with cq2rdf.  If not, see <https://www.gnu.org/licenses/>.

{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE OverloadedStrings #-}

module CineTV.RDF.Void where

import           Data.RDF.State          (RdfState, addPrefixMappings,
                                          addTriple)
import           Data.RDF.Types.Extended (bnodeGen, getUNode, mkTriple,
                                          mkTripleLit, object, predicate,
                                          subject)
import           Import                  hiding (void)
import           SW.Vocabulary
import           Util                    (utcTimeToText)

import           Control.Monad.State     (execState)
import           Data.Hashable           (Hashable (..))
import qualified Data.List               as L
import           Data.RDF                (LValue (..), Node (..), RDF, Rdf,
                                          Triple (..), Triples)
import qualified Data.RDF                as RDF
import           Data.RDF.Namespace      (foaf, mkUri, ns_mappings, owl, rdf,
                                          rdfs, xsd)
import qualified Data.Text               as T
import           Data.Time.Clock         (UTCTime (..))

data CinetvRdf a = CinetvRdf
  { cinetvSnapshotTime :: UTCTime
  , cinetvIssuedTime   :: UTCTime
  , cinetvRdfGraph     :: RDF a
  }

datasetDescUri :: Text
datasetDescUri = "/void/Dataset"

datasetUri :: Text
datasetUri = datasetDescUri <> "#CinemathequeQuebecoiseLinkedOpenDatabase"

wikidataDatasetUri :: Text
wikidataDatasetUri = datasetDescUri <> "#Wikidata"

wikidataLinksetUri :: Text
wikidataLinksetUri =
  datasetDescUri <> "#Wikidata_CinemathequeQuebecoiseLinkedOpenDatabase"

createVoidGraph :: (Rdf a, Rdf b) => CinetvRdf a -> RDF b
createVoidGraph cinetvRdf = do
  execState
    (  defaultVoID
    >> addCreatedDateTime (cinetvSnapshotTime cinetvRdf)
    >> addIssuedDateTime (cinetvIssuedTime cinetvRdf)
    >> addVoIDStats (cinetvRdfGraph cinetvRdf)
    >> addVoidPrefixMappings
    )
    RDF.empty

defaultVoID :: (Rdf a, Monad m) => RdfState a m ()
defaultVoID = do
  mapM_ addTriple $ mkTriple datasetDescUri rdfType voidDatasetDescription
  mapM_ addTriple $ mkTripleLit
    datasetDescUri
    dctermsTitle
    (PlainLL
      "A VoID Description of the Cinémathèque québécoise Linked Open Dataset"
      "en"
    )

  -- Created by Cinémathèque québécoise
  mapM_ addTriple $ mkTriple datasetDescUri dctermsCreator (mkUri wd "Q2973248")
  mapM_ addTriple $ mkTriple datasetDescUri foafPrimaryTopic datasetUri

  mapM_ addTriple $ mkTriple datasetUri rdfType voidDataset
  mapM_ addTriple $ mkTriple datasetUri
                             dctermsLicense
                             "http://www.opendatacommons.org/licenses/odbl/"

addCreatedDateTime :: (Rdf a, Monad m) => UTCTime -> RdfState a m ()
addCreatedDateTime time = do
  let timeText = utcTimeToText time
  mapM_ addTriple
    $ mkTripleLit datasetUri dctermsCreated (TypedL timeText xsdDateTime)

addIssuedDateTime :: (Rdf a, Monad m) => UTCTime -> RdfState a m ()
addIssuedDateTime time = do
  let timeText = utcTimeToText time
  mapM_ addTriple
    $ mkTripleLit datasetUri dctermsIssued (TypedL timeText xsdDateTime)

addVoIDStats
  :: (Rdf rdfImpl1, Rdf rdfImpl2, Monad m)
  => RDF rdfImpl1
  -> RdfState rdfImpl2 m ()
addVoIDStats graph = do
  addNumTriples graph
  addNumEntities graph
  addNumClasses graph
  addNumProperties graph
  addNumDistinctSubjects graph
  addNumDistinctObjects graph
  addClassPartitions graph
  addPropertyPartitions graph
  addWikidataLinkset graph

-- |Add the void:triples triple in the VoID dataset.
addNumTriples
  :: (Rdf rdfImpl1, Rdf rdfImpl2, Monad m)
  => RDF rdfImpl1
  -> RdfState rdfImpl2 m ()
addNumTriples graph = do
  let numTriples = length $ RDF.query graph Nothing Nothing Nothing
  mapM_ addTriple $ mkTripleLit datasetUri
                                voidTriples
                                (TypedL (T.pack $ show numTriples) xsdInteger)

-- |Add the void:entities triple in the VoID dataset.
--
-- The number of entities correspond to the number of distinct subjects and
-- objects from triples.
addNumEntities
  :: (Rdf rdfImpl1, Rdf rdfImpl2, Monad m)
  => RDF rdfImpl1
  -> RdfState rdfImpl2 m ()
addNumEntities graph = do
  let numEntities = getNumEntities graph
  mapM_ addTriple $ mkTripleLit
    datasetUri
    voidEntities
    (TypedL (T.pack $ show numEntities) xsdInteger)

 where
  getNumEntities =
    L.length
      . L.nub
      . filter isEntity
      . concatMap (\t -> [subject t, object t])
      . allTriples

  isEntity node = case node of
    UNode uri -> T.isPrefixOf "/resource" uri
    _         -> False

-- |Add the void:classes triple in the VoID dataset.
--
-- The number of classes include all classes used in the dataset, even from
-- external databases.
addNumClasses
  :: (Rdf rdfImpl1, Rdf rdfImpl2, Monad m)
  => RDF rdfImpl1
  -> RdfState rdfImpl2 m ()
addNumClasses graph = do
  let numClasses = getNumClasses graph
  mapM_ addTriple $ mkTripleLit datasetUri
                                voidClasses
                                (TypedL (T.pack $ show numClasses) xsdInteger)

 where
  getNumClasses = L.length . L.nub . map object . rdfTypeTriples

  rdfTypeTriples g = RDF.query g Nothing (Just $ RDF.unode rdfType) Nothing

-- |Add the void:properties triple in the VoID dataset.
--
-- The number of properties include all properties used in the dataset, even
-- from external databases.
addNumProperties
  :: (Rdf rdfImpl1, Rdf rdfImpl2, Monad m)
  => RDF rdfImpl1
  -> RdfState rdfImpl2 m ()
addNumProperties graph = do
  let numProperties = getNumProperties graph
  mapM_ addTriple $ mkTripleLit
    datasetUri
    voidProperties
    (TypedL (T.pack $ show numProperties) xsdInteger)
  where getNumProperties = L.length . L.nub . map predicate . allTriples

-- |Add the void:distinctSubjects triple in the VoID dataset.
addNumDistinctSubjects
  :: (Rdf rdfImpl1, Rdf rdfImpl2, Monad m)
  => RDF rdfImpl1
  -> RdfState rdfImpl2 m ()
addNumDistinctSubjects graph = do
  let numDistinctSubjects = getNumDistinctSubjects $ allTriples graph
  mapM_ addTriple $ mkTripleLit
    datasetUri
    voidDistinctSubjects
    (TypedL (T.pack $ show numDistinctSubjects) xsdInteger)

getNumDistinctSubjects :: Triples -> Int
getNumDistinctSubjects = L.length . L.nub . filter RDF.isUNode . map subject

-- |Add the void:distinctObjects triple in the VoID dataset.
addNumDistinctObjects
  :: (Rdf rdfImpl1, Rdf rdfImpl2, Monad m)
  => RDF rdfImpl1
  -> RdfState rdfImpl2 m ()
addNumDistinctObjects graph = do
  let numDistinctObjects = getNumDistinctObjects graph
  mapM_ addTriple $ mkTripleLit
    datasetUri
    voidDistinctObjects
    (TypedL (T.pack $ show numDistinctObjects) xsdInteger)

 where
  getNumDistinctObjects =
    L.length . L.nub . filter RDF.isUNode . map object . allTriples

-- |Add all void:classPartition triples in the VoID dataset.
addClassPartitions
  :: (Rdf rdfImpl1, Rdf rdfImpl2, Monad m)
  => RDF rdfImpl1
  -> RdfState rdfImpl2 m ()
addClassPartitions graph = do
  let rdfTypeTriples =
        RDF.query graph Nothing (Just $ RDF.unode rdfType) Nothing
  forM_
    ( L.groupBy (\t1 t2 -> object t1 == object t2)
    $ L.sortOn object rdfTypeTriples
    )
    addClassPartition

addClassPartition :: (Rdf a, Monad m) => Triples -> RdfState a m ()
addClassPartition triples = do
  forM_ (getClassUri triples) $ \classUri -> do
    let classPartitionNode = bnodeGen $ hash classUri
    let numEntities        = getNumDistinctSubjects triples
    addTriple $ Triple (RDF.unode datasetUri)
                       (RDF.unode voidClassPartition)
                       classPartitionNode
    addTriple
      $ Triple classPartitionNode (RDF.unode voidClass) (RDF.unode classUri)
    addTriple $ Triple
      classPartitionNode
      (RDF.unode voidEntities)
      (RDF.lnode $ TypedL (T.pack $ show numEntities) xsdInteger)
  where getClassUri = listToMaybe >=> (return . object) >=> getUNode

-- |Add all void:propertyPartition triples in the VoID dataset.
addPropertyPartitions
  :: (Rdf rdfImpl1, Rdf rdfImpl2, Monad m)
  => RDF rdfImpl1
  -> RdfState rdfImpl2 m ()
addPropertyPartitions graph = do
  forM_
    ( L.groupBy (\t1 t2 -> predicate t1 == predicate t2)
    $ L.sortOn predicate (allTriples graph)
    )
    addPropertyPartition

addPropertyPartition :: (Rdf a, Monad m) => Triples -> RdfState a m ()
addPropertyPartition triples = do
  forM_ (getPropertyUri triples) $ \propUri -> do
    let propertyPartitionNode = bnodeGen $ hash propUri
    let numTriples            = L.length triples
    addTriple $ Triple (RDF.unode datasetUri)
                       (RDF.unode voidPropertyPartition)
                       propertyPartitionNode
    addTriple $ Triple propertyPartitionNode
                       (RDF.unode voidProperty)
                       (RDF.unode propUri)
    addTriple $ Triple
      propertyPartitionNode
      (RDF.unode voidTriples)
      (RDF.lnode $ TypedL (T.pack $ show numTriples) xsdInteger)
  where getPropertyUri = listToMaybe >=> (return . predicate) >=> getUNode

-- |Add all triples related to data linked to Wikidata in the VoID dataset.
addWikidataLinkset
  :: (Rdf rdfImpl1, Rdf rdfImpl2, Monad m)
  => RDF rdfImpl1
  -> RdfState rdfImpl2 m ()
addWikidataLinkset graph = do
  mapM_ addTriple $ mkTriple wikidataLinksetUri rdfType voidLinkset
  mapM_ addTriple $ mkTriple wikidataLinksetUri voidTarget datasetUri
  mapM_ addTriple $ mkTriple wikidataLinksetUri voidTarget wikidataDatasetUri
  mapM_ addTriple $ mkTriple wikidataLinksetUri voidSubset datasetUri
  mapM_ addTriple $ mkTriple wikidataLinksetUri voidLinkPredicate owlSameAs

  let numTriples = length $ RDF.select
        graph
        Nothing
        (Just $ \n -> n == RDF.unode owlSameAs)
        (Just isNodeWikidataUri)
  mapM_ addTriple $ mkTripleLit wikidataLinksetUri
                                voidTriples
                                (TypedL (T.pack $ show numTriples) xsdInteger)

 where
  isNodeWikidataUri n = case n of
    UNode uri -> T.isInfixOf "wikidata.org" uri
    _         -> False

allTriples :: (Rdf a) => RDF a -> Triples
allTriples graph = RDF.query graph Nothing Nothing Nothing

addVoidPrefixMappings :: (Rdf a, Monad m) => RdfState a m ()
addVoidPrefixMappings = do
  let voidPrefixes =
        ns_mappings [rdf, rdfs, owl, void, dcterms, foaf, wd, xsd, wd, formats]
  addPrefixMappings voidPrefixes True
